# NOTE: This workflow is DISABLED - AutumnsGrove repo doesn't deploy to Cloudflare
# Keeping the file for reference. To re-enable: remove both `if: false` lines below.

name: Sync Posts to CloudFlare D1

on:
  push:
    branches:
      - main
    paths:
      - 'UserContent/Posts/**'
  workflow_dispatch:  # Allow manual triggering

jobs:
  sync-posts:
    if: false  # DISABLED - this repo doesn't deploy
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Setup pnpm
      uses: pnpm/action-setup@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'pnpm'

    - name: Install dependencies
      run: pnpm install --frozen-lockfile

    - name: Read and process posts
      id: process-posts
      run: |
        node << 'EOF'
        const fs = require('fs');
        const path = require('path');
        const matter = require('gray-matter');

        // Normalize slug to kebab-case (matches worker normalization)
        function normalizeSlug(slug) {
          return slug
            .toLowerCase()
            .trim()
            .replace(/\s+/g, '-')
            .replace(/_+/g, '-')
            .replace(/[^a-z0-9-]/g, '')
            .replace(/-+/g, '-')
            .replace(/^-+|-+$/g, '');
        }

        // Process gutter manifest for a post
        function processGutterContent(postsDir, slug) {
          const gutterDir = path.join(postsDir, slug, 'gutter');
          const manifestPath = path.join(gutterDir, 'manifest.json');

          if (!fs.existsSync(manifestPath)) {
            return null;
          }

          try {
            const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
            const items = manifest.items || [];

            // Process each item - read .md files for comment content
            const processedItems = items.map(item => {
              if ((item.type === 'comment' || item.type === 'markdown') && item.file) {
                // Check if it's a local file (not a URL)
                if (!item.file.startsWith('http')) {
                  const mdPath = path.join(gutterDir, item.file);
                  if (fs.existsSync(mdPath)) {
                    const content = fs.readFileSync(mdPath, 'utf8').trim();
                    return { ...item, content, file: undefined };
                  }
                }
              }
              // For photos/galleries with file field pointing to URL, rename to url
              if ((item.type === 'photo' || item.type === 'image') && item.file && item.file.startsWith('http')) {
                return { ...item, url: item.file, file: undefined };
              }
              return item;
            });

            return processedItems;
          } catch (err) {
            console.error(`Warning: Failed to process gutter for ${slug}:`, err.message);
            return null;
          }
        }

        const postsDir = './UserContent/Posts';
        const posts = [];

        // Read all markdown files
        const files = fs.readdirSync(postsDir).filter(file => file.endsWith('.md'));

        for (const file of files) {
          const filePath = path.join(postsDir, file);
          const content = fs.readFileSync(filePath, 'utf8');

          // Generate SEO-friendly slug
          const rawSlug = file.replace('.md', '');
          const slug = normalizeSlug(rawSlug);

          if (!slug) {
            console.error(`Warning: Could not generate valid slug for file: ${file}`);
            continue;
          }

          // Process gutter content if it exists
          const gutterContent = processGutterContent(postsDir, rawSlug);

          const postData = {
            slug,
            content,
            filePath
          };

          if (gutterContent && gutterContent.length > 0) {
            postData.gutterContent = gutterContent;
            console.log(`Processed: ${file} -> ${slug} (with ${gutterContent.length} gutter items)`);
          } else {
            console.log(`Processed: ${file} -> ${slug}`);
          }

          posts.push(postData);
        }

        // Write posts to a JSON file to avoid shell escaping issues
        fs.writeFileSync('posts-data.json', JSON.stringify(posts));

        // Output post count for the next step
        fs.appendFileSync(process.env.GITHUB_OUTPUT, `post-count=${posts.length}\n`);

        console.log(`Total posts processed: ${posts.length}`);
        EOF

    - name: Sync posts to CloudFlare D1
      env:
        WORKER_URL: ${{ secrets.CLOUDFLARE_WORKER_URL }}
        SYNC_API_KEY: ${{ secrets.CLOUDFLARE_SYNC_API_KEY }}
      run: |
        echo "Syncing ${{ steps.process-posts.outputs.post-count }} posts to CloudFlare D1..."

        # Call the CloudFlare Worker sync endpoint using the JSON file
        RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
          "$WORKER_URL/sync" \
          -H "Authorization: Bearer $SYNC_API_KEY" \
          -H "Content-Type: application/json" \
          -d @posts-data.json)
        
        # Extract response body and status code
        HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
        RESPONSE_BODY=$(echo "$RESPONSE" | sed '$d')
        
        echo "Response Status: $HTTP_STATUS"
        echo "Response Body: $RESPONSE_BODY"
        
        # Check if the request was successful
        if [ "$HTTP_STATUS" -eq 200 ]; then
          echo "‚úÖ Posts synced successfully!"
          
          # Parse and display results
          SYNCED=$(echo "$RESPONSE_BODY" | jq -r '.synced // 0')
          ERRORS=$(echo "$RESPONSE_BODY" | jq -r '.errors // []')
          
          echo "Posts synced: $SYNCED"
          
          if [ "$(echo "$ERRORS" | jq 'length')" -gt 0 ]; then
            echo "‚ö†Ô∏è  Some posts had errors:"
            echo "$ERRORS" | jq -r '.[] | "  - \(.slug): \(.error)"'
            exit 1
          fi
        else
          echo "‚ùå Failed to sync posts"
          echo "Error: $RESPONSE_BODY"
          exit 1
        fi
        
    - name: Update sync status
      if: success()
      run: |
        echo "‚úÖ All posts have been successfully synced to CloudFlare D1 database!"
        echo "üìä Sync Summary:"
        echo "  - Total posts processed: ${{ steps.process-posts.outputs.post-count }}"
        echo "  - Sync completed at: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
        
    - name: Handle sync failure
      if: failure()
      run: |
        echo "‚ùå Post sync failed!"
        echo "Please check the logs above for details."
        echo "You can also manually trigger the sync from the Actions tab."